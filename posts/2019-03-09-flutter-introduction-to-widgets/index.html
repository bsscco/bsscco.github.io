<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.100.2" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="bsscco" />
  <meta property="og:url" content="https://bsscco.github.io/posts/2019-03-09-flutter-introduction-to-widgets/" />
  <link rel="canonical" href="https://bsscco.github.io/posts/2019-03-09-flutter-introduction-to-widgets/" /><link rel="alternate" type="application/atom+xml" href="https://bsscco.github.io/index.xml" title="Android Developer BSSCCO">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/bsscco.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "Flutter로 개발하기(01) - 위젯 소개",
      "headline" : "Flutter로 개발하기(01) - 위젯 소개",
      "description" : "Introduction to widgets https:\/\/flutter.dev\/docs\/development\/ui\/widgets-intro\n플러터 위젯은 React로부터 영감을 받아 반응형 스타일로 제작됐습니다.\n플러터 위젯의 중심 아이디어는 위젯으로만 UI를 제작하는 것입니다. 위젯은 자신에게 주어진 상태에 따라 어떻게 그릴 것인가를 기술하는 객체입니다. 위젯의 상태가 바뀌면 위젯은 다시 빌드되는데, 이때 프레임워크는 이전 상태와 다음 상태를 비교해서 render tree가 최소한만 변경되도록 합니다.\nHello World 플러터 앱은 runApp() 함수를 호출하는 것에서부터 시작됩니다.\nimport \u0026#39;package:flutter\/meterial.dart\u0026#39;; void main() { runApp( Center( child: Text( \u0026#39;Hello, world!\u0026#39;, textDirection: TextDirection.ltr, ), ), ); } runApp() 함수는 주어진 위젯으로 위젯트리의 루트를 만듭니다.",
      "inLanguage" : "en-US",
      "author" : "bsscco",
      "creator" : "bsscco",
      "publisher": "bsscco",
      "accountablePerson" : "bsscco",
      "copyrightHolder" : "bsscco",
      "copyrightYear" : "2019",
      "datePublished": "2019-03-09 06:49:58 \u002b0000 UTC",
      "dateModified" : "2019-03-09 06:49:58 \u002b0000 UTC",
      "url" : "https:\/\/bsscco.github.io\/posts\/2019-03-09-flutter-introduction-to-widgets\/",
      "keywords" : [ "flutter", ]
  }
</script>
<title>Flutter로 개발하기(01) - 위젯 소개</title>
  <meta property="og:title" content="Flutter로 개발하기(01) - 위젯 소개" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="Introduction to widgets https://flutter.dev/docs/development/ui/widgets-intro
플러터 위젯은 React로부터 영감을 받아 반응형 스타일로 제작됐습니다.
플러터 위젯의 중심 아이디어는 위젯으로만 UI를 제작하는 것입니다. 위젯은 자신에게 주어진 상태에 따라 어떻게 그릴 것인가를 기술하는 객체입니다. 위젯의 상태가 바뀌면 위젯은 다시 빌드되는데, 이때 프레임워크는 이전 상태와 다음 상태를 비교해서 render tree가 최소한만 변경되도록 합니다.
Hello World 플러터 앱은 runApp() 함수를 호출하는 것에서부터 시작됩니다.
import &amp;#39;package:flutter/meterial.dart&amp;#39;; void main() { runApp( Center( child: Text( &amp;#39;Hello, world!&amp;#39;, textDirection: TextDirection.ltr, ), ), ); } runApp() 함수는 주어진 위젯으로 위젯트리의 루트를 만듭니다." />
  <meta name="description" content="Introduction to widgets https://flutter.dev/docs/development/ui/widgets-intro
플러터 위젯은 React로부터 영감을 받아 반응형 스타일로 제작됐습니다.
플러터 위젯의 중심 아이디어는 위젯으로만 UI를 제작하는 것입니다. 위젯은 자신에게 주어진 상태에 따라 어떻게 그릴 것인가를 기술하는 객체입니다. 위젯의 상태가 바뀌면 위젯은 다시 빌드되는데, 이때 프레임워크는 이전 상태와 다음 상태를 비교해서 render tree가 최소한만 변경되도록 합니다.
Hello World 플러터 앱은 runApp() 함수를 호출하는 것에서부터 시작됩니다.
import &amp;#39;package:flutter/meterial.dart&amp;#39;; void main() { runApp( Center( child: Text( &amp;#39;Hello, world!&amp;#39;, textDirection: TextDirection.ltr, ), ), ); } runApp() 함수는 주어진 위젯으로 위젯트리의 루트를 만듭니다." />
  <meta property="og:locale" content="ko-kr" /><meta property="og:image" content="" />
  

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{text-align:center}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Android Developer BSSCCO">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Android Developer BSSCCO</a
    >
  </div>
  <div class="header-subtitle"></div>
</header>
<div class="row end-md center-xs header-items">
  
  <div class="header-item">
    <a href="https://github.com/bsscco" target="_blank">Github</a>
  </div>
  
</div>
<div class="row end-xs">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Flutter로 개발하기(01) - 위젯 소개</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-03-09 06:49:58 UTC">
                09 Mar 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://github.com/bsscco">@bsscco</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <h1 id="introduction-to-widgets">Introduction to widgets</h1>
<p><a href="https://flutter.dev/docs/development/ui/widgets-intro">https://flutter.dev/docs/development/ui/widgets-intro</a></p>
<p>플러터 위젯은 React로부터 영감을 받아 반응형 스타일로 제작됐습니다.</p>
<p>플러터 위젯의 중심 아이디어는 위젯으로만 UI를 제작하는 것입니다. 위젯은 자신에게 주어진 상태에 따라 어떻게 그릴 것인가를 기술하는 객체입니다. 위젯의 상태가 바뀌면 위젯은 다시 빌드되는데, 이때 프레임워크는 이전 상태와 다음 상태를 비교해서 render tree가 최소한만 변경되도록 합니다.</p>
<h2 id="hello-world">Hello World</h2>
<p>플러터 앱은 runApp() 함수를 호출하는 것에서부터 시작됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;package:flutter/meterial.dart&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>  runApp(
</span></span><span style="display:flex;"><span>    Center(
</span></span><span style="display:flex;"><span>      child: Text(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;Hello, world!&#39;</span>,
</span></span><span style="display:flex;"><span>        textDirection: TextDirection.ltr,
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/2019-03-10/run-app.png" alt="runApp.png"></p>
<p><code>runApp()</code> 함수는 주어진 위젯으로 위젯트리의 루트를 만듭니다. 위 예제에서 위젯트리는 Center와 Text로 구성됩니다.</p>
<p>위젯의 주요 기능은 build() 함수를 구현하는 것입니다.</p>
<p>우리는 일반적으로 상태가 없는 StatelessWidget 또는 상태를 가지는 StatefulWidget 클래스를 상속해서 새로운 위젯을 만들 것입니다.</p>
<h2 id="기본-위젯">기본 위젯</h2>
<p>Flutter는 강력한 기본 위젯들을 제공합니다.</p>
<ul>
<li>Text: 스타일을 적용할 수 있는 텍스트를 제공합니다.</li>
<li>Row, Column: 수평적인 배치와 수직적인 배치를 할 수 있게 해줍니다. 이 위젯들은 웹의 flexbox layout model에 기초해서 설계됐습니다.</li>
<li>Stack: 위젯들을 순서에 따라 쌓일 수 있게 해줍니다. Stack 위젯 안에서 Positioned 위젯을 사용하면 자식 위젯들의 상대적인 위치를 지정할 수 있습니다. Stack 위젯은 웹의 absolute positioning layout model을 기반으로 합니다.</li>
<li>Container: 사각형의 보이는 요소를 만들어줍니다. BoxDecoration을 사용해서 테두리, 배경색, 그림자 등을 설정할 수 있습니다. Container는 그밖에 margin, padding, 자신의 크기에 적용할 제약조건도 가질 수 있습니다. 그리고 x, y, z 세축에서 모양을 변형시킬 수도 있습니다.</li>
</ul>
<p>아래는 위젯들을 조합해 사용한 간단한 예입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;package:flutter/material.dart&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAppBar</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  MyAppBar({<span style="color:#66d9ef">this</span>.title});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// StatelessWidget의 필드는 항상 final로 선언합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">final</span> Widget title;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Container(
</span></span><span style="display:flex;"><span>      height: <span style="color:#ae81ff">156.0</span>, <span style="color:#75715e">// 플러터에서는 논리적인 픽셀단위를 사용합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      padding: <span style="color:#66d9ef">const</span> EdgeInsets.symmetric(horizontal: <span style="color:#ae81ff">8.0</span>),
</span></span><span style="display:flex;"><span>      decoration: BoxDecoration(color: Colors.blue[<span style="color:#ae81ff">500</span>]),
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Row는 수평적인 선형 배치입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      child: Row(
</span></span><span style="display:flex;"><span>        children: <span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>          IconButton(
</span></span><span style="display:flex;"><span>            icon: Icon(Icons.menu),
</span></span><span style="display:flex;"><span>            tooltip: <span style="color:#e6db74">&#39;Navigation menu&#39;</span>,
</span></span><span style="display:flex;"><span>            onPressed: <span style="color:#66d9ef">null</span>, <span style="color:#75715e">// onPressed에 null값을 설정하면 Button이 disable상태로 설정됩니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          ),
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// Expanded는 자식 위젯이 여백을 채우게 합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          Expanded(
</span></span><span style="display:flex;"><span>            child: title,
</span></span><span style="display:flex;"><span>          ),
</span></span><span style="display:flex;"><span>          IconButton(
</span></span><span style="display:flex;"><span>            icon: Icon(Icons.search),
</span></span><span style="display:flex;"><span>            tooltip: <span style="color:#e6db74">&#39;Search&#39;</span>,
</span></span><span style="display:flex;"><span>            onPressed: <span style="color:#66d9ef">null</span>,
</span></span><span style="display:flex;"><span>          ),
</span></span><span style="display:flex;"><span>        ],
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyScaffold</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Material(
</span></span><span style="display:flex;"><span>      child: Column(
</span></span><span style="display:flex;"><span>        children: <span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>          MyAppBar(
</span></span><span style="display:flex;"><span>            title: Text(
</span></span><span style="display:flex;"><span>              <span style="color:#e6db74">&#39;Example title&#39;</span>,
</span></span><span style="display:flex;"><span>              style: Theme.of(context).primaryTextTheme.title,
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>          ),
</span></span><span style="display:flex;"><span>          Expanded(
</span></span><span style="display:flex;"><span>            child: Center(
</span></span><span style="display:flex;"><span>              child: Text(<span style="color:#e6db74">&#39;Hello, world!&#39;</span>),
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>          ),
</span></span><span style="display:flex;"><span>        ],
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>  runApp(MaterialApp(
</span></span><span style="display:flex;"><span>    title: <span style="color:#e6db74">&#39;My app&#39;</span>, <span style="color:#75715e">// used by the OS task switcher
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    home: MyScaffold(),
</span></span><span style="display:flex;"><span>  ));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/2019-03-10/combine-widgets.png" alt="combine-widgets.png"></p>
<p>pubspec.yaml 파일에서 uses-material-design: true 으로 설정했는지 확인하세요. 이 설정은 미리 정의된 Material Icons를 사용할 수 있게 해줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">name</span>: <span style="color:#ae81ff">my_app</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">flutter</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">uses-material-design</span>: <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><h2 id="머터리얼-컴포넌트-사용하기">머터리얼 컴포넌트 사용하기</h2>
<p>플러터는 머터리얼 디자인을 위한 여러 위젯을 제공합니다. 머터리얼 앱은 MaterialApp 위젯을 루트로 하는 것에서 시작됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;package:flutter/material.dart&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>  runApp(MaterialApp(
</span></span><span style="display:flex;"><span>    title: <span style="color:#e6db74">&#39;Flutter Tutorial&#39;</span>,
</span></span><span style="display:flex;"><span>    home: TutorialHome(),
</span></span><span style="display:flex;"><span>  ));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TutorialHome</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scaffold는 주요 머터리얼 컴포넌트 사용을 위한 위젯입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> Scaffold(
</span></span><span style="display:flex;"><span>      appBar: AppBar(
</span></span><span style="display:flex;"><span>        leading: IconButton(
</span></span><span style="display:flex;"><span>          icon: Icon(Icons.menu),
</span></span><span style="display:flex;"><span>          tooltip: <span style="color:#e6db74">&#39;Navigation menu&#39;</span>,
</span></span><span style="display:flex;"><span>          onPressed: <span style="color:#66d9ef">null</span>,
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        title: Text(<span style="color:#e6db74">&#39;Example title&#39;</span>),
</span></span><span style="display:flex;"><span>        actions: <span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>          IconButton(
</span></span><span style="display:flex;"><span>            icon: Icon(Icons.search),
</span></span><span style="display:flex;"><span>            tooltip: <span style="color:#e6db74">&#39;Search&#39;</span>,
</span></span><span style="display:flex;"><span>            onPressed: <span style="color:#66d9ef">null</span>,
</span></span><span style="display:flex;"><span>          ),
</span></span><span style="display:flex;"><span>        ],
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// body는 화면에 보여지는 영역입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      body: Center(
</span></span><span style="display:flex;"><span>        child: Text(<span style="color:#e6db74">&#39;Hello, world!&#39;</span>),
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>      floatingActionButton: FloatingActionButton(
</span></span><span style="display:flex;"><span>        tooltip: <span style="color:#e6db74">&#39;Add&#39;</span>, <span style="color:#75715e">// 접근성 기능에서 사용됩니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        child: Icon(Icons.add),
</span></span><span style="display:flex;"><span>        onPressed: <span style="color:#66d9ef">null</span>,
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/2019-03-10/material-widgets.png" alt="material-widgets.png"></p>
<p>위 예제에서는 MyAppBar와 MyScaffold를 material.dart의 AppBar와 Scaffold로 바꾸었습니다. 그 결과 앱바 하단 그림자가 자동으로 설정되는 등 더 머터리얼 스러워졌습니다.</p>
<p>더 많은 정보: <a href="https://flutter.dev/docs/development/ui/widgets/material">Material components</a></p>
<h2 id="제스처-다루기">제스처 다루기</h2>
<p>대부분의 앱은 사용자입력 폼을 포함합니다. 상호작용하는 앱을 제작하는 첫 번째 스탭은 제스처 입력을 감지하는 것입니다. 어떻게 하는지 아래를 봅시다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyButton</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> GestureDetector(
</span></span><span style="display:flex;"><span>      onTap: () {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;MyButton was tapped!&#39;</span>);
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      child: Container(
</span></span><span style="display:flex;"><span>        height: <span style="color:#ae81ff">36.0</span>,
</span></span><span style="display:flex;"><span>        padding: <span style="color:#66d9ef">const</span> EdgeInsets.all(<span style="color:#ae81ff">8.0</span>),
</span></span><span style="display:flex;"><span>        margin: <span style="color:#66d9ef">const</span> EdgeInsets.symmetric(horizontal: <span style="color:#ae81ff">8.0</span>),
</span></span><span style="display:flex;"><span>        decoration: BoxDecoration(
</span></span><span style="display:flex;"><span>          borderRadius: BorderRadius.circular(<span style="color:#ae81ff">5.0</span>),
</span></span><span style="display:flex;"><span>          color: Colors.lightGreen[<span style="color:#ae81ff">500</span>],
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        child: Center(
</span></span><span style="display:flex;"><span>          child: Text(<span style="color:#e6db74">&#39;Engage&#39;</span>),
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>GestureDetector 위젯은 사용자에게 보이지는 않지만 사용자의 제스처를 감지합니다. 사용자가 Container 위에서 tap 했을 때 GestureDetector는 자신의 onTab을 호출합니다. GestureDetector는 drag, scale 등도 감지할 수 있습니다.</p>
<p>많은 위젯들이 GestureDetector를 사용합니다. IconButton, RaisedButton, FloatingActionButton 등은 사용자가 tab 했을 때 자신의 onPressed를 호출합니다.</p>
<p>더 많은 정보: <a href="https://flutter.dev/docs/development/ui/advanced/gestures">Gestures in Flutter</a></p>
<h2 id="입력에-반응해-위젯-변경하기">입력에 반응해 위젯 변경하기</h2>
<p>지금까지는 StatelessWidget만 사용해봤습니다. StatelessWidget에서는 부모 위젯으로부터 인자를 내려받아 final 멤버로 저장합니다. 이 인자들은 build() 메소드에서 UI를 생성할 때 사용됩니다.</p>
<p>더 복잡한 UI를 빌드하기 위해서 어플리케이션은 상태(state)를 사용합니다. 플러터는 이 아이디어를 구현하기 위해 StatefulWidget을 사용합니다. StatefulWidget은 상태 객체를 생성할 수 있는 특별한 위젯입니다. RaisedButton을 사용하는 다음 예제을 보겠습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> <span style="color:#66d9ef">extends</span> StatefulWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 이 위젯 클래스는 아래의 State를 위해 함께 구성돼어야 하는 클래스입니다. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 이 클래스는 부모로부터 제공된 값들과 State의 build() 메소드를 위해 사용될 값들을 담습니다. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 위젯 클래스의 모든 필드는 final로 선언되어야 합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  _CounterState createState() <span style="color:#f92672">=&gt;</span> _CounterState();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_CounterState</span> <span style="color:#66d9ef">extends</span> State<span style="color:#f92672">&lt;</span>Counter<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> _increment() {
</span></span><span style="display:flex;"><span>    setState(() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// setState() 메소드는 Flutter 프레임워크에게 State가 변경됐다는 것을 말해줍니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 아래 build() 메소드가 다시 실행되고, 그로 인해 UI에 갱신된 값들이 반영됩니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 만약 setState() 메소드를 호출하지 않고 _counter를 변경한다면, build() 메소드는 호출되지 않을 것입니다. 그렇게 되면 UI도 바뀌지 않습니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 이 메소드는 위의 setState() 메소드가 호출될 때마다 다시 실행됩니다. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Flutter 프레임워크는 build() 메소드를 빠르게 다시 실행시킬 수 있도록 최적화 돼있습니다. 그래서 갱신이 필요할 때면 언제든 리빌드를 해도 괜찮습니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> Row(
</span></span><span style="display:flex;"><span>      children: <span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>        RaisedButton(
</span></span><span style="display:flex;"><span>          onPressed: _increment,
</span></span><span style="display:flex;"><span>          child: Text(<span style="color:#e6db74">&#39;Increment&#39;</span>),
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#39;Count: </span><span style="color:#e6db74">$</span>_counter<span style="color:#e6db74">&#39;</span>),
</span></span><span style="display:flex;"><span>      ],
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>왜 StatefulWidget과 State가 두 객체로 분리되는지 궁금할 것입니다. 플러터에서 두 유형의 객체들은 다른 라이프사이클을 가집니다. Widget 객체는 현재 상태의 프리젠테이션을 만들기 위해 사용되는 일시적인 객체입니다. 반대로, State 객체는 build() 메소드의 여러 호출에서도 그 정보를 유지합니다.</p>
<p>위 예제는 사용자 입력을 받아들이고, 그 결과를 build() 메소드에서 직접 사용합니다. 더 복잡한 어플리케이션에서는 위젯들이 각자 다른 동작을 책임질 것입니다. 예를 들어, 한 위젯은 정보를 모으는 목적으로 사용자 입력을 받는 복잡한 UI를 보여주고 , 또 다른 위젯은 전체적인 프리젠테이션의 변경을 위해 그 정보를 사용할 것입니다.</p>
<p>플러터에서 변경에 대한 알림들은 콜백 방법을 통해 위젯 계층의 위 방향으로 흘러갑니다. 반면에, 현재 상태의 프레젠테이션은 위젯 계층의 아래에 있는 StatelessWidget을 향해 아래 방향으로 흘러갑니다. 이 흐름을 발생시키는 공통의 부모가 State입니다. 다음 예제는 이것이 어떻게 동작하는지 보여줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#75715e">// 현재 상태를 프레젠테이션 하는 stateless 위젯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterDisplay</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  CounterDisplay({<span style="color:#66d9ef">this</span>.count});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Text(<span style="color:#e6db74">&#39;Count: </span><span style="color:#e6db74">$</span>count<span style="color:#e6db74">&#39;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 사용자 입력을 받는 stateless 위젯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterIncrementor</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  CounterIncrementor({<span style="color:#66d9ef">this</span>.onPressed});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> VoidCallback onPressed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> RaisedButton(
</span></span><span style="display:flex;"><span>      onPressed: onPressed,
</span></span><span style="display:flex;"><span>      child: Text(<span style="color:#e6db74">&#39;Increment&#39;</span>),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// State를 위해 필요한 stateful 위젯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> <span style="color:#66d9ef">extends</span> StatefulWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  _CounterState createState() <span style="color:#f92672">=&gt;</span> _CounterState();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 사용자 입력으로 모인 정보를 사용해 변경 알림의 흐름을 만들어내는 State
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_CounterState</span> <span style="color:#66d9ef">extends</span> State<span style="color:#f92672">&lt;</span>Counter<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> _counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> _increment() {
</span></span><span style="display:flex;"><span>    setState(() {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">++</span>_counter;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// CounterIncrementor는 사용자 입력을 받아 정보를 모읍니다. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 사용자 입력이 있을 때 _CounterState로부터 받은 콜백을 호출합니다. 정보는 이 콜백을 통해 위젯 계층 위로 흘러갑니다. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// _CounterState는 정보를 사용해 상태(_counter)를 변경하고, 이 상태 변경은 CounterDisplay가 있는 위젯 계층 아래로 흘러갑니다.   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// CounterDisplay는 바뀐 상태를 UI에 반영합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Row(children: <span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>      CounterIncrementor(onPressed: _increment), 
</span></span><span style="display:flex;"><span>      CounterDisplay(count: _counter),  
</span></span><span style="display:flex;"><span>    ]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>카운터를 보여주는 것(CounterDisplay)과 카운터를 변경(CounterIncrementor)하는 것의 관심사의 분리를 명심하세요.</p>
<p>더 많은 정보:</p>
<ul>
<li><a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html">StatefulWidget</a></li>
<li><a href="https://docs.flutter.io/flutter/widgets/State/setState.html">State.setState</a></li>
</ul>
<h2 id="위-내용들을-모두-사용한-예제">위 내용들을 모두 사용한 예제</h2>
<p>다음 예제는 위에서 소개한 것들을 함께 가져온 더 완전한 예제입니다. 가상의 쇼핑 어플리케이션은 세일 중인 다양한 제품을 보여줍니다. 이 앱은 장바구니 담기 기능도 가집니다. 프레젠테이션 클래스인 ShoppingListItem을 정의하는 것으로 시작합시다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Product({<span style="color:#66d9ef">this</span>.name});
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">String</span> name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span> CartChangedCallback(Product product, <span style="color:#66d9ef">bool</span> inCart);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShoppingListItem</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  ShoppingListItem({Product product, <span style="color:#66d9ef">this</span>.inCart, <span style="color:#66d9ef">this</span>.onCartChanged})
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">:</span> product <span style="color:#f92672">=</span> product,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>(key: ObjectKey(product));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> Product product;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">bool</span> inCart;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> CartChangedCallback onCartChanged;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Color _getColor(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 여기서 사용되는 테마는 BuildContext에 의존합니다. tree의 다른 부분이 다른 테마를 가질 수 있기 때문입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// BuildContext는 build가 실행되는 위치를 가리킵니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inCart <span style="color:#f92672">?</span> Colors.black54 <span style="color:#f92672">:</span> Theme.of(context).primaryColor;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  TextStyle _getTextStyle(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>inCart) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TextStyle(
</span></span><span style="display:flex;"><span>      color: Colors.black54,
</span></span><span style="display:flex;"><span>      decoration: TextDecoration.lineThrough,
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ListTile(
</span></span><span style="display:flex;"><span>      onTap: () {
</span></span><span style="display:flex;"><span>        onCartChanged(product, <span style="color:#f92672">!</span>inCart);
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      leading: CircleAvatar(
</span></span><span style="display:flex;"><span>        backgroundColor: _getColor(context),
</span></span><span style="display:flex;"><span>        child: Text(product.name[<span style="color:#ae81ff">0</span>]),
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>      title: Text(product.name, style: _getTextStyle(context)),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ShoppingListItem 위젯은 stateless 위젯의 일반적인 패턴을 따릅니다. 이 위젯은 생성자에서 받은 값을 final 멤버 변수로 저장합니다. 이 값은 build() 함수에서 사용됩니다. 예를 들어, inCart boolean은 두 visual appearances 사이에서 토글됩니다. 하나는 현재 테마로부터 primary color를 사용하고, 다른 하나는 grey를 사용합니다.</p>
<p>사용자가 리스트 아이템을 tap 했을 때 이 위젯은 자신의 inCart 값을 직접 변경하지 않습니다. 대신에 부모 위젯으로부터 전달받았던 onCartChanged() 함수를 호출합니다. 이 패턴은 상태를 위젯 계층의 더 높은 곳에 저장하게 하고, 더 긴 시간 동안 상태가 유지되도록 합니다.</p>
<p>부모 위젯이 onCartChanged 콜백을 받았을 때 부모 위젯은 상태를 갱신합니다. 갱신이 트리거가 되어 그 위젯을 리빌드 하게 하고, 새로운 inCart값을 포함하는 새로운 ShoppingListItem 객체가 생성되게 됩니다. 비록 부모 위젯이 리빌드 과정에서 새로운 ShoppingListItem 객체를 생성한다고 해도 프레임워크는 새롭게 빌드 되어야 할 위젯들을 비교하고 RenderObject 위에서 필요한 부분만 적용하기 때문에 이 명령에 들어가는 비용은 적습니다.</p>
<p>다음은 변경 가능한 상태를 저장하는 부모 위젯의 예제입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShoppingList</span> <span style="color:#66d9ef">extends</span> StatefulWidget {
</span></span><span style="display:flex;"><span>  ShoppingList({Key key, <span style="color:#66d9ef">this</span>.products}) <span style="color:#f92672">:</span> <span style="color:#66d9ef">super</span>(key: key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> List<span style="color:#f92672">&lt;</span>Product<span style="color:#f92672">&gt;</span> products;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 프레임워크는 위젯이 tree에 위치가 주어지고 나타나는 처음 한 번 createState() 함수를 호출합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 만약 부모 위젯이 같은 위젯 유형(같은 key)을 사용하고 rebuild 한다면, 프레임워크는 State 객체를 생성하는 대신에 재사용할 것입니다.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  _ShoppingListState createState() <span style="color:#f92672">=&gt;</span> _ShoppingListState();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_ShoppingListState</span> <span style="color:#66d9ef">extends</span> State<span style="color:#f92672">&lt;</span>ShoppingList<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  Set<span style="color:#f92672">&lt;</span>Product<span style="color:#f92672">&gt;</span> _shoppingCart <span style="color:#f92672">=</span> Set<span style="color:#f92672">&lt;</span>Product<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> _handleCartChanged(Product product, <span style="color:#66d9ef">bool</span> inCart) {
</span></span><span style="display:flex;"><span>    setState(() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 사용자가 카트 안의 무언가를 변경할 때 rebuild를 실행시키기 위해 setState() 메소드 안에서 _shoppingCart의 변경하는 동작이 필요합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 그러면 프레임워크는 build를 호출할 것이고, 앱의 visual appearance는 갱신될 것입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (inCart)
</span></span><span style="display:flex;"><span>        _shoppingCart.add(product);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        _shoppingCart.remove(product);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Scaffold(
</span></span><span style="display:flex;"><span>      appBar: AppBar(
</span></span><span style="display:flex;"><span>        title: Text(<span style="color:#e6db74">&#39;Shopping List&#39;</span>),
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>      body: ListView(
</span></span><span style="display:flex;"><span>        padding: EdgeInsets.symmetric(vertical: <span style="color:#ae81ff">8.0</span>),
</span></span><span style="display:flex;"><span>        children: widget.products.map((Product product) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> ShoppingListItem(
</span></span><span style="display:flex;"><span>            product: product,
</span></span><span style="display:flex;"><span>            inCart: _shoppingCart.contains(product),
</span></span><span style="display:flex;"><span>            onCartChanged: _handleCartChanged,
</span></span><span style="display:flex;"><span>          );
</span></span><span style="display:flex;"><span>        }).toList(),
</span></span><span style="display:flex;"><span>      ),
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main() {
</span></span><span style="display:flex;"><span>  runApp(MaterialApp(
</span></span><span style="display:flex;"><span>    title: <span style="color:#e6db74">&#39;Shopping App&#39;</span>,
</span></span><span style="display:flex;"><span>    home: ShoppingList(
</span></span><span style="display:flex;"><span>      products: <span style="color:#f92672">&lt;</span>Product<span style="color:#f92672">&gt;</span>[
</span></span><span style="display:flex;"><span>        Product(name: <span style="color:#e6db74">&#39;Eggs&#39;</span>),
</span></span><span style="display:flex;"><span>        Product(name: <span style="color:#e6db74">&#39;Flour&#39;</span>),
</span></span><span style="display:flex;"><span>        Product(name: <span style="color:#e6db74">&#39;Chocolate chips&#39;</span>),
</span></span><span style="display:flex;"><span>      ],
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>  ));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/2019-03-10/shopping-list.png" alt="shopping-list.png"></p>
<p>ShoppingList 클래스는 StatefulWidget을 상속합니다. 이것은 변경 가능한 상태를 저장한다는 것을 의미합니다. ShoppingList 위젯이 처음 tree에 삽입될 때 프레임워크는 최신의 <em>ShoppingListState 객체를 생성하기 위해 createState() 함수를 호출합니다. (State의 서브클래스들은 private으로 구현되도록 하는 underscore(</em>)로 이름이 시작되도록 이름지어야 한다는 것을 명심하세요.)</p>
<p>ShoppingList 위젯의 부모가 리빌드 될 때 ShoppingList 객체도 새로 만들 것입니다. ShoppingList의 재생성과 달리 프레임워크는 _ShoppingListState를 재사용할 것입니다.</p>
<p>_ShoppingListState는 현재의 ShoppingList의 속성에 접근하기 위해서 <code>widget</code> 속성을 사용합니다. 만약 부모 위젯이 리빌드 되고 새로운 ShoppingList를 생성된다면, widget 속성도 바뀔 것입니다. <code>widget</code> 속성이 바뀌었을 때 알림을 받고 싶다면, didUpdateWidget() 함수를 override 할 수 있습니다.</p>
<p>onCartChanged() 콜백이 핸들링될 때 _ShoppingListState는 _shoppingCart로부터 제품을 삭제하거나 추가하는 등 자신의 상태를 변경합니다. 이 상태가 바뀌었다는 신호를 프레임워크에게 보내기 위해 setState() 함수를 호출합니다. setState() 호출은 위젯이 바뀌어야 할 부분을 추려내고, 앱이 화면을 갱신하는 다음 시간에 리빌드 되도록 스케줄링 합니다. 만약 setState()를 호출하는 것을 잊어버린다면, 프레임워크는 위젯의 변경될 부분을 알지 못할 것이고 위젯의 build() 함수도 호출되지 않을 것입니다. 그것은 UI가 변경된 상태를 반영하지 않을 것을 의미합니다.</p>
<p>이 방법으로 상태를 관리함으로써 자식 위젯들을 생성하고 갱신하는 코드를 분리해서 작성할 필요가 없습니다. 대신에 간단히 build() 함수를 구현하기만 하면 됩니다.</p>
<h2 id="위젯의-생명주기">위젯의 생명주기</h2>
<p>StatefulWidget에서 createState() 함수를 호출한 후에 프레임워크는 새로운 상태 객체를 tree에 삽입합니다. 그리고 상태 객체의 initState()를 호출합니다. State의 서브클래스는 initState()를 override할 수 있습니다. 예를 들어, 애니메이션을 구성하거나 플랫폼 서비스를 구독하기 위해 initState()를 override 할 수 있습니다. initState()의 구현부는 super.initState()의 호출로 시작되어야 합니다.</p>
<p>상태 객체가 더 이상 필요하지 않을 때 프레임워크는 상태 객체의 dispose()를 호출합니다. 작업은 clean up 하기 위해 dispose() 함수를 override 할 수 있습니다. 예를 들어, 타이머를 취소하거나 플랫폼 서비스로부터 구독을 해지하기 위해 dispose()를 override 할 수 있습니다. 일반적으로 구현부의 끝에 super.dispose()를 삽입합니다.</p>
<p>더 많은 정보: <a href="https://docs.flutter.io/flutter/widgets/State-class.html">State</a></p>
<h2 id="keys">Keys</h2>
<p>위젯이 rebuild 될 때 프레임워크가 위젯을 매칭시키는 것을 제어하기 위해 key를 사용할 수 있습니다. 기본적으로 프레임워크는 runtimeType과 표시 순서로 현재와 이전 빌드의 위젯을 매칭합니다. key를 사용하면, 프레임워크는 현재와 이전 빌드의 위젯들이 동일한 runtimeType과 동일한 key를 가질 것을 요구합니다.</p>
<p>key는 같은 유형의 많은 위젯 인스턴스들을 build 하는 위젯에서 가장 유용합니다. 예를 들어, ShoppingList 위젯은 표시 영역들을 채우기에 충분히 많은 ShoppingListItem 인스턴스들을 build 한다고 가정해봅시다.</p>
<p>key가 없다면, 현재 build의 첫 번째 항목은 이전 빌드의 첫 번째 항목과 항상 동기화 됩니다. (역자 주:  ListView를 스크롤하면서 ListView Top에 걸렸던 항목 A는 위로 올라가고, A 아래에 있던 항목 B가 ListView Top에 걸리게 된다고 가정했을 때 A, B 두 항목에 key가 없으면 프레임워크는 항목 A, B 둘 다 같은 runtimeType, 같은 표시 순서이기 때문에 같은 위젯으로 인식하고 같은 상태를 공유하게 만들어버리는 문제가 발생합니다.)</p>
<p>각 항목에 의미를 지니는 key를 할당함으로써 infinite 리스트는 똑똑해집니다. 각 항목 위젯에 유지되는 상태가 뷰포트 기반이 아니라, 동일한 의미 순서에 맞게 제대로 연결되는 것입니다.</p>
<p>더 많은 정보: <a href="https://docs.flutter.io/flutter/foundation/Key-class.html">Key API</a></p>
<h2 id="전역-keys">전역 Keys</h2>
<p>자식 위젯들을 구별하기 위해 global key를 사용할 수 있습니다. global key는 모든 위젯 계층을 통틀어 유니크 해야 합니다. global key는 주어진 위젯과 연결된 상태를 찾는 데 사용될 수 있습니다.</p>
<p>더 많은 정보: <a href="https://docs.flutter.io/flutter/widgets/GlobalKey-class.html">GlobalKey API</a></p>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-tags">
              <a href="/tags/flutter/">
                flutter
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          

<div class="related-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/posts/2019-03-02-dart-sample-code/">Dart 샘플코드 번역</a></li>
    
    <li><a href="/posts/2019-02-16-flutter-firebase-for-flutter/">Flutter 코드랩 리뷰 - 플러터를 위한 파이어베이스</a></li>
    
    <li><a href="/posts/2019-02-14-flutter-build-beautiful-ui-with-flutter/">Flutter 코드랩 리뷰 - 플러터로 아름다운 UI 만들기</a></li>
    
  </ul>
</div>



          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>